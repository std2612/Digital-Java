int number;
int number=10;

double score=90.5;
float score=90.5f; (플롯은 f가 붙어야 한다)

char ch='A'; (문자는 ' ' 안에 있는 문자, 문자열은 " " 안에 있는 문자열)
'1' 은 문자 1을 뜻한다 (숫자1 X)
'12' : 잘못된 코드 (12라는 문자는 없다)
"1" : 문자열1
"12" : 문자열 12
문자는 보통 1글자
문자열은 여러 글자가 가능

boolean isEven=true;

int x=1,y=2;

long num=21474836470L;
float num=1.23f;

print() : 원하는 문자열을 출력하는 메소드 (문자열 필요)
println() : 원하는 문자열을 출력 후 엔터를 치는 메소드 (문자열 불필요)
printf() : 정형화된 문자열을 출력하는 메소드로 (문자열 필요)
	->문자열의 형태를 지정할 수 있음.

중첩 if문 : if 문 안에 실행문으로 if문이 오는 경우
if(조건문1){
	if(조건식2){
		실행문1;
	}
}

switch문
1. 사용되는 변수의 값이 제한적인 경우
2. 사용되는 식의 결과가 제한적인 경우
switch(변수나 식){
	case 값1:
		실행문1;
		break; // switch문을 빠져 나가는 역할
	case 값2:
		실행문2;
		break;
	default:
		실행문3;
}
if(변수나 식 == 값1){
	실행문1;
}else if(변수나 식 == 값2){
	실행문2;
}else{
	실행문3;

min <= M*(max-min+1)+min < max+1

반복문
규칙성을 가진 작업을 반복적으로 할 때 사용
1. 규칙성 찾기
2. 반복 횟수
for, while / do while
for문 문법
for(1. 초기화; 2. 조건식; 4.7. 증감연산식){
	3.6. 실행문
}
1. 초기화 : 조건식이나 실행문에서 사용하는 변수의 값을 초기화하는 곳으로 생략할 수
	있고, 여러 변수를 콤마(,)를 통해 초기화 할 수 있다.
2. 조건식 : 반복문이 실행 되기 위한 조건으로 참이면 반복문을 계속 실행, 거짓이면
	반복문을 종료, 생략할 수 있으며 생략할 경우 무조건 참
3. 실행문
4. 증감연산식 : 조건식에서 사용하는 변수를 증가 또는 감소시켜서 반복 횟수를
	조절하는 식, 생략할 수 있음
반복문에서 반복 횟수는 초기화 + 조건식 + 증감연산식이 함께 관여한다

연산
 - 산술 : + - * / %
(double)정수 / 정수 => 실수
 - 비교연산자 : 크기 비교, 조건식
 - 논리연산자 : &&, ||, !, 조건식
 - 대입연산자 : =, 오른쪽에 있는 값을 왼쪽에 저장
변수 = 값;
int num = 3;
int num = (int)3.1;
int num = 3.1; (오류)
 조건문에서 같다(==)와 대입연산자를 혼동하지 말자
 - 증감연산자 : ++, --

조건문 : ~(조건식)하면 ...(실행문)한다
else : '현재 위치'를 기준으로 위에 있는 모든 조건식이 거짓이면

반복문 : 규칙성을 가진 작업을 반복적으로 할 때
1. 반복 횟수 : 초기화, 조건식, 증감연산식	//
2. 규칙성 : 실행문				// ***중요***
3 .반복문 종료후				//

for(1.초기화; 2.5.8조건식; 4,7증감연산식){
	3.6실행문;
}

break

continue : 스킵, for문에서는 증감연산식 위치로, while문에서는 조건식으로

while(조건식){
	실행문;
}

초기화;
while(조건식){
	실행문;
	증감연산식;
}

do while문은 무조건 1번은 실행된다
(for, while은 조건식에 따라서 1번도 실행되지 않을 수 있다)
실행문이 먼저 실행되기 때문

do{
	실행문;
while(조건식);

배열 - (같은 의미와) 같은 자료형을 가진 변수들의 집합
왜?
 - 일반 변수 10개를 이용해서는 반복문을 사용할 수 없다.
 - 효율적으로 변수들을 관리하기 위해

-배열 선언
자료형[] 배열명;
자료형 배열명 [];

int score[]=new int[5];

int num1, num2, gcd, i;
int arr[]=new int[4]

배열 - (같은 의미의) 같은 자료형을 가진 변수들의 집합
자료형 배열명[];
자료형 []배열명;

 - 0 ~ 크기-1

for(int i=0; i<arr2.length; i++){

}

-향상된 for문
for(자료형 변수명 : 배열){
	실행문;
}

String : 문자열을 관리하는 클래스 - 참조 변수

두 정수와 문자 하나를 입력받아 출력하는 코드를 작성하세요.

int a=0, b=0;
char ch='A'
Scanner scan=new Scanner(System.in);


카메라 설계도	클래스
카메라		객체(인스턴스)
사진을 찍는다	메서드(method)
렌즈, 셔터	멤버변수

클래스
 - 멤버변수 : 부품
 - 메서드 : 기능
 - 생성자 : 멤버변수의 초기화

접근제한자 class 클래스명{
접근제한자 멤버변수; // 여러개 올수있음
접근제한자 메서드; // 여러개 올수잇음
생성자;
}

접근제한자
 - public : 누구나 사용 가능
 - private : 나만 사용 가능, 일반적으로 클래스에 붙이지는 않는다.
 - protected : 나 + 패키지 + 자식클래스
 - default : 나 + 패키지 (접근제한자를 생략하면 기본적으로 쓰임)

메서드 - 기능
접근제한자 (static) 리턴타입 메서드명 (매개변수들){

	구현
	return값;

생성자 : 멤버변수 초기화
//기본 생성자
public 클래스명(){

}
//생성자 오버로딩
public 클래스명(매개변수){

}
아래의 조건을 만족하면 이름이 같은 메서드나 생성자가 존재할 수 있다.
- 매개변수가 달라지는 경우
 1. 매개변수의 갯수가 달라지는 경우
 2. 매개변수의 타입이 달라지는 경우

변수
 - 일반변수 : 실제 사용하는 값을 저장하는 변수
 - 참조변수 : 주소를 저장하는 변수 = 누군가와 연결되 있음을 뜻함.

 - 지역변수
 - 객체변수(멤버변수)
 - 클래스변수
int num = 10; -일반변수

클래스 변수(static) : 객체 생성 없이 사용
클래스 메서드
 - 객체 생성 없이 사용 => 클래스명.메서드명()으로 사용
 - 클래스 메서드에는 객체변수를 사용할 수 없음
 - 클래스 메서드에는 객체 메서드를 사용할 수 없음

멤버변수 : 객체를 생성해야 사용 가능
멤버 메서드 :
 - 클래스 변수를 사용할 수 있다.

객체 지향 프로그래밍
 - 무언가를 할 때 객체를 만들어서 하는 것

다음 중 어느 내용이 객체지향에 해당하는가?
1. 사진을 찍는다.
2. 카메라를 사진찍는 기능을 이용하여 사진을 찍는다.

클래스 	제품 설계도
객체	제품
메서드 	기능

 - 클래스의 구성 요소
1. 멤버변수 : 속성, 부품
 - 객체변수
 - 클래스변수
2. 메서드 : 기능
 - 객체메서드
 - 클래스메서드
3. 생성자 : 초기화
 - 기본
 - 오버로딩

클래스 : 아이폰
 - 클래스 변수 : 제조사
 - 객체 변수 : 기기번호, 볼륨, 밝기, 배터리 잔량
 
 - 클래스 메소드 : 아이폰 켰을 때 화면 띄우기
 - 객체 메소드 : 배경화면 설정

 - 생성자 : 아이폰을 만들 때 색상을 정해서 만듬

접근제한자 : 접근할 수 있는 여부를 결정하는 키워드
public : 모두 사용 가능
 - 클래스 : 무조건 파일명과 클래스명이 같을 때
 - 멤버변수 : 상수일때
 - 메서드 : 대부분의 메서드가 public

private : 해당 클래스만 사용 가능
 - 멤버변수 : 대부분의 멤버 변수는 private으로 사용
 - 메서드 : 다른 클래스에서 사용하는 메서드가 아니라 내부에서 사용하는 메서드인 경우
	(코드를 줄이기 위해

protected : 상속받은 클래스 + 나 +패키지

() : default : 나 + 패키지

 - 클래스 생성방법
접근제한자 class 클래스명{
	접근제한자 자료형 변수명; // 객체 변수
	접근제한자 static 자료형 변수명; // 클래스 변수
	
	접근제한자 리턴타입 메서드명(매개변수){ // 객체 메서드
	}
	접근제한자 static 리턴타입 메서드명(매개변수){ //클래스 메서드
	}
	public 클래스명(){
	}
	public 클래스명(매개변수){
	}
 - 메서드 선언방법

접근제한자 static 리턴타입 메서드명(매개변수){

}

메서드 : 하나의 기능을 하도록 모아놓은 코드
클래스 : 어떠한 정보를 나타내기 의해 모아놓은 코드
 - 변수 : 정보를 관리
 - 메서드 : 기능을 관리 - 편하게 쓰기 위해
 - 생성자 : 변수 초기화

메소드와 생성자의 호출하는 시기
 - 메소드는 메소드를 호출할 때마다 실행
 - 생성자는 객체를 생성할 때만 실행, 생성자는 중간에 직접 호출할 수 없다.

오버로딩 : 동일한 이름을 가진 생성자나 메소드가 2개 이상인 경우 다음을 만족하면
	오버로딩, 만족하지 않으면 에러 발생
 - 매개변수가 달라야 한다.
 1. 갯수
 2. 자료형

클래스 변수/메서드 : static
객체 변수/메서드 : static X

-클래스 변수는 객체 메서드에서 사용 가능하다. 		O
-객체변수는 클래스 메서드에서 사용 가능하다. 		X
-클래스 메서드는 객체 메서드에서 사용 가능하다.	O
-객체 메서드는 클래스 메서드에서 사용 가능하다.	X

Point{
	private int x, y;
	public void print(){}
	public void move(int x1, int y1){}
	pubic void setX(int x1){}
	public int getX(){} 
}

에러 내용
변수명 cannot be resolved to a variable
에러 원인
변수를 선언하지 않고 사용해서 => 변수 선언

에러 내용
The local variable 변수명 may not have been initialized
에러 원인
변수를 초기화하지 않고 값을 사용해서 => 변수 초기화

에러 내용
Duplicate local variable 변수명
에러 원인
변수를 중복 선언해서 => 변수명 수정 또는 변수 삭제

에러 내용
Syntax error on token "else", delete this token
에러 원인
if문이 ;에 의해 끝난 후 else가 온 경우 => ;삭제

에러 내용
The left-hand side of an assignment must be a variable
에러 상황
else if를 써야하는데 else를 쓰고 조건문을 쓰는 경우 해당 조건문이 실행문으로
인식이 되고 따라서 왼쪽에 변수명이 와야한다.
=>else if를 쓰던지 else의 조건문을 제거

상속 - 부모 클래스한테 멤버변수나 멤버메소드를 물려 받는 것
키워드 : extends
상속은 클래스를 생성할 때 받는 것

class 클래스명 extends 부모클래스명{
// 멤버변수
// 멤버 메서드
// 생성자
}

//상속 받은 클래스는 부모 클래스의 public 또는 protected로 되어 있는 멤버변수와
	멤버 메서드를 사용할 수 있다.

생성자와 초기화 블럭은 상속되지 않지만 부모의 생성자를 호출할 수는 있다.

부모는 1명만 가능

A는 B이다 => 성립, 말이 되면 => 상속, B:부모 A:자식
A는 B를 가지고 있다 => 성립 => 포함, A:클래스, B:멤버변수

원은 도형이다 => 도형 : 부모, 원 : 자식
원은 점(중심)을 가지고 있다 => 원:클래스, 점:멤버변수

스마트폰, 카메라 => 스마트폰:클래스, 카메라:멤버변수

상속과 포함의 차이
상속은 자식이 사용할 수 없는 것 : private으로 된 메서드나 멤버변수
포함은 클래스가 멤버변수에서 사용할 수 없는 것
 : private나 protected로 된 메서드나 멤버변수

상속은 멤버변수(일반변수)를 사용하기 위해 초기화를 하지 않아도 된다.
포함에서 멤버변수(객체)는 new를 이용하여 객체를 생성 후 해당 객체의
멤버변수(일반변수)를 사용할 수 있다.

포함 : 클래스A의 멤버변수로 클래스B의 객체가 오는 것
	Child클래스의 멤버변수로 Parent의 객체가 오는 것

class A{
	public void test(){}
}
class B{
	public void test(){}
}
class C extends A{

}

public		: 나 + 패키지 + 자식클래스들 + 일반클래스들
protected	: 나 + 패키지 + 자식클래스들
default		: 나 + 패키지
private		: 나

this()와 super()는 생성자 코드에서만 사용 가능하다
다른 메서드에서는 사용할 수 없다.

this.는 내 객체정보, this()는 내 생성자
super.는 부모 객체정보, super()는 부모 생성자
